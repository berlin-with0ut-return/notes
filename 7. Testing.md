# 7. Testing
## Overview
### Testing
- code must work for simple + edge cases
### TDD
- write test before fx to understand it
- isolate errors w/ unit tests
- problem: can be slow, doesn't address fx interactions
### JUnit
- package for debugging
- `assertEquals`, `assertFalse`, `assertNotNull`, etc
- use `@Test` annotation to allow nonstatic running
# Exercises
## C Level
### Problem 1
In general, is it good to write tests that test your entire program? How about for specific functions?

**Ans**: 
![Both is good.](https://64.media.tumblr.com/03d19e83eaf67ef680e8fbbe53a6051c/tumblr_oxvsg1sZGC1tx7nmpo3_500.jpg)
You need both unit and integration tests. Unit testing allows you to isolate problems and verify that the basic components of your program work; integration tests make sure that nothing goes wrong when these units interact.

## B Level
### Problem 1
Write a testing method that will take in 2 arrays and see if they are equal. These arrays can have nested arrays and those nested arrays can have nested arrays and so forth.
```java
public boolean nestedArrayEquals(Object[] arr1, Object[] arr2){
	return Arrays.deepEquals(arr1, arr2);
}
```
*Note: if anyone has a better solution without using deepEquals please let me know. I found actually implementing deepEquals from scratch to be too complex.*

### Problem 2
If we have 2 objects, Object o1 and Object o2, that have identical qualities, will `assertEquals(o1, o2)` assert true or false?
